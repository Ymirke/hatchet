// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: log_line.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type InsertLogLineParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	Message        string             `json:"message"`
	Metadata       []byte             `json:"metadata"`
}

const listLogLines = `-- name: ListLogLines :many
SELECT
    id, created_at, tenant_id, task_id, task_inserted_at, message, level, metadata
FROM   
    v1_log_line l
WHERE
    l.tenant_id = $1::uuid
    AND l.task_id = $2::bigint
    AND l.task_inserted_at = $3::timestamptz
    AND ($4::text IS NULL OR l.message LIKE concat('%', $4::text, '%'))
ORDER BY
    l.created_at ASC
LIMIT COALESCE($6, 1000)
OFFSET COALESCE($5, 0)
`

type ListLogLinesParams struct {
	Tenantid       pgtype.UUID        `json:"tenantid"`
	Taskid         int64              `json:"taskid"`
	Taskinsertedat pgtype.Timestamptz `json:"taskinsertedat"`
	Search         pgtype.Text        `json:"search"`
	Offset         interface{}        `json:"offset"`
	Limit          interface{}        `json:"limit"`
}

func (q *Queries) ListLogLines(ctx context.Context, db DBTX, arg ListLogLinesParams) ([]*V1LogLine, error) {
	rows, err := db.Query(ctx, listLogLines,
		arg.Tenantid,
		arg.Taskid,
		arg.Taskinsertedat,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1LogLine
	for rows.Next() {
		var i V1LogLine
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TenantID,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.Message,
			&i.Level,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
